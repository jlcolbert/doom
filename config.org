#+title:     Doom Emacs Literate Config
#+author:    Jay L. Colbert
#+email:     jaylcolbert@gmail.com

* Table of Contents :toc_3:
- [[#introduction][Introduction]]
  - [[#why-emacs][Why Emacs?]]
  - [[#using-this-config][Using this config]]
  - [[#current-issues][Current issues]]
  - [[#possible-future-features][Possible future features]]
- [[#rudimentary-configuration][Rudimentary Configuration]]
  - [[#personal-information][Personal information]]
  - [[#better-defaults][Better defaults]]
    - [[#simple-settings][Simple settings]]
    - [[#frame-sizing][Frame sizing]]
- [[#doom-configuration][Doom configuration]]
  - [[#modules][Modules]]
    - [[#completion][Completion]]
    - [[#ui][UI]]
    - [[#editor][Editor]]
    - [[#tools][Tools]]
    - [[#languages][Languages]]
  - [[#visual-settings][Visual settings]]
    - [[#font-face][Font face]]
    - [[#theme][Theme]]
    - [[#line-numbers][Line numbers]]
- [[#packages][Packages]]
  - [[#consult-org-roam][Consult-org-roam]]
  - [[#doct][Doct]]
  - [[#hydra-posframe][Hydra-posframe]]
  - [[#info-colors][Info-colors]]
  - [[#major-mode-hydra][Major-mode-hydra]]
  - [[#org-ol-tree][Org-ol-tree]]
  - [[#org-roam-desktop][Org-roam-desktop]]
  - [[#org-transclusion][Org-transclusion]]
  - [[#rotate][Rotate]]
  - [[#zetteldesk][Zetteldesk]]
- [[#documents][Documents]]
  - [[#configel][=config.el=]]
  - [[#packagesel][=packages.el=]]
  - [[#autoloads][Autoloads]]
    - [[#hydrasel][=hydras.el=]]
    - [[#iconsel][=icons.el=]]
    - [[#org-captureel][=org-capture.el=]]
    - [[#org-roamel][=org-roam.el=]]
    - [[#posframeel][=posframe.el=]]

* Introduction
** Why Emacs?
** Using this config
If you want your setup exactly like mine, here are the necessary prerequisites.
All of these commands are run on the command line.

*Have a Mac*

   I'm on the M1 chip now.

*Install Homebrew*

#+begin_src sh :tangle no
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
#+end_src

*Install Emacs Plus*

   I am on Emacs 28, built with native compilation.
   You don't have to do native comp, but it's supposed to be faster I think.
   I also added a different icon, but that's not necessary.
#+begin_src sh :tangle no
brew tap d12frosted/emacs-plus
brew install emacs-plus@28 --with-native-comp --with-nobu417-big-sur-icon
ln -s /opt/homebrew/Cellar/emacs-plus@27/27.2/Emacs.app /Applications
#+end_src

*Install Doom*

   First we need some dependencies:
#+begin_src sh :tangle no
# required dependencies
brew install git ripgrep
# optional dependencies
brew install coreutils fd
# Installs clang
xcode-select --install
#+end_src

  Now we can install Doom.
  This will take forever because of the native comp.
#+begin_src sh :tangle no
git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.config/emacs
~/.config/emacs/bin/doom install
#+end_src

  I put my configs in =~/.config= as much as possible.
  The documentation puts it in a =~/.emacs.d= folder.

  Then I add it to my ~PATH~.
  I use the fish shell, so my way of doing this will be different.
  Change as necessary for your shell.
#+begin_src sh :tangle no
fish_add_path $HOME/.config/emacs/bin
#+end_src

  Now we can use the ~doom~ utility.
  I recommend running ~doom sync~ first.

  My standard workflow after installing/removing packages or changing =init.el= is:
#+begin_src sh :tangle no
doom sync -up
doom purge -g
doom doctor
#+end_src

For the rest of my setup, please see my dotfiles.

** Current issues
** Possible future features
* Rudimentary Configuration
** Personal information
Enter in the info we want when things auto-fill names/emails.
I think this also involves GPG, but I'm not sure.
#+begin_src elisp :tangle no :noweb-ref personal-info
(setq user-full-name    "Jay L. Colbert"
      user-mail-address "jaylcolbert@gmail.com")
#+end_src

** Better defaults
*** Simple settings
I have ADHD, so I need to see the time and battery in the program.
Otherwise, I won't remember to look up at the time in my Mac menu bar.
#+begin_src elisp :tangle no :noweb-ref simple-settings
(display-time-mode 1)
(display-battery-mode 1)
#+end_src

I don't want to see =.DS_Store= files when I'm searching.
#+begin_src elisp :tangle no :noweb-ref simple-settings
(add-to-list 'completion-ignored-extensions ".DS_Store")
#+end_src

*** Frame sizing
I use =emacs-plus=.
It's great, but there's one things that =emacs-mac= did that I miss:
centering the initial frame and sizing it in a way I really liked.
Changing my settings to replicate that is takes a few steps.
According to the =initial-frame-alist= documentation:
#+begin_quote
You can specify geometry-related options for just the initial
frame by setting this variable in your init file; however, they
won't take effect until Emacs reads your init file, which happens
after creating the initial frame.  If you want the initial frame
to have the proper geometry as soon as it appears, you need to
use this three-step process:
+ Specify X resources to give the geometry you want.
+ Set default-frame-alist to override these options so that they
  don't affect subsequent frames.
+ Set initial-frame-alist in a way that matches the X resources,
  to override what you put in default-frame-alist.
#+end_quote

So let's do that.

Newer Macs don't use X to manage windows.
They use Cocoa (which has NSWindow).
Luckily, specifying this geometry is the same process.
It's been a little fussy, but it's good enough for me right now.
We set the width and height in characters and the position of the top left corner in pixels.
(So you need to figure out the pixel position.
I have a program that will center windows on my screen.
I did that, and then I went to take a screenshot but only for a specific section.
It gives you a little crosshair with the pixel position.
I put the crosshair there and used those pixel coordinates.)
#+begin_src sh :tangle no
defaults write org.gnu.Emacs Width 80
defaults write org.gnu.Emacs Height 40
defaults write org.gnu.Emacs Top 181
defaults write org.gnu.Emacs Left 422
#+end_src

Next, we can set =default-frame-alist= to override our geometry settings.
I don't care about the position of default frames.
I rarely use more than one frame, so the geometry defaults and the initial frame settings usually do the trick for me.
I also don't mind the size of the default frame when I do create additional ones.

Finally, it tells us to set =initial-frame-alist= to match our geometry settings.
The width and height parameters are set the same, but I think top and left are percentage/fractional.
These settings replicate my defaults above:
#+begin_src elisp :tangle no :noweb-ref frame-sizing
(setq initial-frame-alist
      '((top . 0.5) (left . 0.5) (width . 80) (height . 40)))
#+end_src

* Doom configuration
** Modules
This is where I configure the modules I've activated in =init.el=.
Other packages are configured elsewhere.
*** Completion
**** Company
I hate when the completion suggestions pop up super fast.
This gives a bit of a delay.
#+begin_src elisp :tangle no :noweb-ref company
(after! company
  (setq company-idle-delay 0.5))
#+end_src

*** UI
**** Deft
I have Deft enabled, but I need to do my config for it.
I don't really use it that much, but it's something that I know is already installed or something by another package, so I like to at least have the Doom configuration turned on.

**** Doom
These are the Doom settings meant to be configured outside of module configuration.
The first two just give the buffer a nicer looking name when there's nothing in it.
The third is from Tecosaur.
It puts some cool icons that indicate if something is an Org Roam file or a project file.
It also lets you know if you've saved your changes via some neat circles.
Finally, we have another delay setting.
This time, it speeds up the Which Key menu.
This variable says to set it before Which Key loads, which is why I'm not configuring it as its own module.
#+begin_src elisp :tangle no :noweb-ref doom
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom"
      frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name)))))
      which-key-idle-delay 0.5)
#+end_src

**** Modeline
Another Tecosaur creation.
This improves the PDF information in the modeline and cleans up the buffer name.
#+begin_src elisp :tangle no :noweb-ref modeline
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

*** Editor
**** Evil
Ensures a new window is always created to the right or below.
It also keeps the cursor from moving back when entering normal mode.
I do this to make adding links and citations easier for me.

When creating a new window, it will now prompt for the buffer or file you want to open.

And then, we add some keybindings to use arrows to navigate windows.
We can also rotate layouts.
#+begin_src elisp :tangle no :noweb-ref evil
(after! evil
  (setq evil-vsplit-window-right t
        evil-split-window-below t
        evil-move-cursor-back t
        evil-kill-on-visual-paste nil)
  (defadvice! prompt-for-buffer (&rest _)
    :after '(evil-window-split evil-window-vsplit)
    (consult-buffer))
  (map! :map evil-window-map
        "SPC" #'rotate-layout
        ;; Navigation
        "<left>"     #'evil-window-left
        "<down>"     #'evil-window-down
        "<up>"       #'evil-window-up
        "<right>"    #'evil-window-right
        ;; Swapping windows
        "C-<left>"       #'+evil/window-move-left
        "C-<down>"       #'+evil/window-move-down
        "C-<up>"         #'+evil/window-move-up
        "C-<right>"      #'+evil/window-move-right))
#+end_src

*** Tools
**** Biblio
Because this is the configuration for my personal laptop, not my work laptop (I'm a librarian, but I also have faculty status), I don't do as much research on here as on there.
However, I am working on a second degree, so being able to write and cite is crucial.
I also have a Zettelkasten, and I like being able to cite with that.

Because I use Vertico, the bibliographic package to complement org-cite is citar.
All of these settings are from the Citar page.
#+begin_src elisp :tangle no :noweb-ref citar
(after! citar
  ;; use consult-completing-read for enhanced interface
  (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)
  (setq! citar-bibliography   '("~/Documents/org/digital-garden/org/biblio.bib")
         citar-library-paths  '("~/Documents/Zotero"))
  (setq citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))
        citar-symbol-separator "  "))
#+end_src

*** Languages
**** Clojure
I mainly use Clojure for generative art.
My setup isn't that complicated because of it.

To be written (I haven't made art in a few months)...

**** Org
According to the Doom documentation, the Org directory needs to be set before org-mode loads.
Because I have that whole frame title thing that involves org-roam, I also load that immediately.
#+begin_src elisp :tangle no :noweb-ref org-dirs
(setq org-directory       "~/Documents/org/"
      org-roam-directory  (file-truename "~/Documents/org/digital-garden/org"))
#+end_src

Configuring org and the module flags I enabled is a little complicated.
I nest the configurations.
I think I'm allowed to do that.
#+begin_src elisp :tangle no :noweb-ref org :noweb yes
(after! org
  <<org-visuals>>
  <<org-capture>>
  <<org-journal>>
  <<org-roam>>)
#+end_src

***** Visuals
When I'm reading, I don't like to see the emphasis markers.
I also like having a fancy little triangle for the ellipsis in headings and other collapsible items.
#+begin_src elisp :tangle no :noweb-ref org-visuals
(setq org-hide-emphasis-markers t
      org-ellipsis " ▾ ")
#+end_src

And then configuring this package means the emphasis markers will show back up when my cursor is inside that word/phrase.
I turned it off for links because it made navigating around my org-roam files really annoying.
#+begin_src elisp :tangle no :noweb-ref org-appear
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

***** Capture
Alright, this is a big one.

Basically all of this is from tecosaur's config.
Because it's so complicated, I'm also breaking it up into pieces.
#+begin_src elisp :tangle no :noweb-ref org-capture :noweb yes
(after! org-capture
  <<prettify-capture>>
  <<org-capture-templates>>)
#+end_src

I autoload this function.
It's part of the settings that make the capture template popup look better.
#+begin_src elisp :tangle no :noweb-ref org-capture-select-template-prettier
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
#+end_src

And same thing here.
#+begin_src elisp :tangle no :noweb-ref org-mks-pretty
(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
#+end_src

And then here is where we set our templates.
I tried autoloading this function, too, but I couldn't get it to work.
I need to play around with that.

I removed the Recipe template, and I added a Slipbox template right at the top.
This is where I capture "fleeting notes" for my Zettelkasten:
notes that aren't ready to actually be literature notes, but notes which I do want to flesh out.
#+begin_src elisp :tangle no :noweb-ref org-capture-templates
(setq doct-after-conversion-functions '(+doct-iconify-capture-templates))
(defun set-org-capture-templates ()
  (setq org-capture-templates
        (doct `(("Slipbox" :keys "s"
                 :icon ("inbox" :set "octicon" :color "green")
                 :file "digital-garden/org/inbox.org"
                 :type entry
                 :template ("* %?\n"))
                ("Personal todo" :keys "t"
                 :icon ("checklist" :set "octicon" :color "green")
                 :file +org-capture-todo-file
                 :prepend t
                 :headline "Inbox"
                 :type entry
                 :template ("* TODO %?"
                            "%i %a"))
                ("Personal note" :keys "n"
                 :icon ("sticky-note-o" :set "faicon" :color "green")
                 :file +org-capture-todo-file
                 :prepend t
                 :headline "Inbox"
                 :type entry
                 :template ("* %?"
                            "%i %a"))
                ("Email" :keys "e"
                 :icon ("envelope" :set "faicon" :color "blue")
                 :file +org-capture-todo-file
                 :prepend t
                 :headline "Inbox"
                 :type entry
                 :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                            "Send an email %^{urgency|soon|ASAP|anon|at some point|eventually} to %^{recipient}"
                            "about %^{topic}"
                            "%U %i %a"))
                ("Interesting" :keys "i"
                 :icon ("eye" :set "faicon" :color "lcyan")
                 :file +org-capture-todo-file
                 :prepend t
                 :headline "Interesting"
                 :type entry
                 :template ("* [ ] %{desc}%? :%{i-type}:"
                            "%i %a")
                 :children (("Webpage" :keys "w"
                             :icon ("globe" :set "faicon" :color "green")
                             :desc "%(org-cliplink-capture) "
                             :i-type "read:web")
                            ("Article" :keys "a"
                             :icon ("file-text" :set "octicon" :color "yellow")
                             :desc ""
                             :i-type "read:reaserch")
                            ("Information" :keys "i"
                             :icon ("info-circle" :set "faicon" :color "blue")
                             :desc ""
                             :i-type "read:info")
                            ("Idea" :keys "I"
                             :icon ("bubble_chart" :set "material" :color "silver")
                             :desc ""
                             :i-type "idea")))
                ("Tasks" :keys "k"
                 :icon ("inbox" :set "octicon" :color "yellow")
                 :file +org-capture-todo-file
                 :prepend t
                 :headline "Tasks"
                 :type entry
                 :template ("* TODO %? %^G%{extra}"
                            "%i %a")
                 :children (("General Task" :keys "k"
                             :icon ("inbox" :set "octicon" :color "yellow")
                             :extra "")
                            ("Task with deadline" :keys "d"
                             :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                             :extra "\nDEADLINE: %^{Deadline:}t")
                            ("Scheduled Task" :keys "s"
                             :icon ("calendar" :set "octicon" :color "orange")
                             :extra "\nSCHEDULED: %^{Start time:}t")))
                ("Project" :keys "p"
                 :icon ("repo" :set "octicon" :color "silver")
                 :prepend t
                 :type entry
                 :headline "Inbox"
                 :template ("* %{time-or-todo} %?"
                            "%i"
                            "%a")
                 :file ""
                 :custom (:time-or-todo "")
                 :children (("Project-local todo" :keys "t"
                             :icon ("checklist" :set "octicon" :color "green")
                             :time-or-todo "TODO"
                             :file +org-capture-project-todo-file)
                            ("Project-local note" :keys "n"
                             :icon ("sticky-note" :set "faicon" :color "yellow")
                             :time-or-todo "%U"
                             :file +org-capture-project-notes-file)
                            ("Project-local changelog" :keys "c"
                             :icon ("list" :set "faicon" :color "blue")
                             :time-or-todo "%U"
                             :heading "Unreleased"
                             :file +org-capture-project-changelog-file)))
                ("\tCentralised project templates"
                 :keys "o"
                 :type entry
                 :prepend t
                 :template ("* %{time-or-todo} %?"
                            "%i"
                            "%a")
                 :children (("Project todo"
                             :keys "t"
                             :prepend nil
                             :time-or-todo "TODO"
                             :heading "Tasks"
                             :file +org-capture-central-project-todo-file)
                            ("Project note"
                             :keys "n"
                             :time-or-todo "%U"
                             :heading "Notes"
                             :file +org-capture-central-project-notes-file)
                            ("Project changelog"
                             :keys "c"
                             :time-or-todo "%U"
                             :heading "Unreleased"
                             :file +org-capture-central-project-changelog-file)))))))
(set-org-capture-templates)
(unless (display-graphic-p)
  (add-hook 'server-after-make-frame-hook
            (defun org-capture-reinitialise-hook ()
              (when (display-graphic-p)
                (set-org-capture-templates)
                (remove-hook 'server-after-make-frame-hook
                             #'org-capture-reinitialise-hook)))))
#+end_src

And then this makes all this work or something? I'm not sure.
#+begin_src elisp :tangle no :noweb-ref prettify-capture
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

***** Journal
I really only have journal enabled on my personal machine for the TTRPGs I play with my friends.
It's a good way to take notes and automatically have it linked to a date.
I also like using the journal for intersitial journaling.
#+begin_src elisp :tangle no :noweb-ref org-journal
(setq org-journal-dir "~/Documents/org/journal/"
      org-journal-date-prefix "* "
      org-journal-time-prefix "** "
      org-journal-date-format "%B %d, %Y (%A) "
      org-journal-file-format "%Y-%m-%d.org")
#+end_src

***** Roam
I try to be tool-agnostic and even method-agnostic.
There is no one tool, no one method, that will be perfect for me.
However, the Zettelkasten technique does seem to align with how my brain processes information.
I have tried many tools, but org-roam is the one I like best.

This is gonna be complicated, so chunking it up once again.
#+begin_src elisp :tangle no :noweb-ref org-roam :noweb yes
(after! org-roam
  <<consult-org-roam>>
  <<node-draft-hook>>
  <<org-roam-node-type>>
  (setq
   <<org-roam-capture-templates>>
   <<org-roam-node-display-template>>))
#+end_src

****** Smart notes workflow
These settings are largely pulled from jethrokuan's [[https://jethrokuan.github.io/org-roam-guide/][How I Take Notes with Org-roam]].
Side note, I agree with his decision to not include a productivity system in this.
My Zettelkasten can be used for productivity, but it is not only about that.
I do not want this to be a task management system, like GTD.
When I feel the need to put a task management system on this computer, I like using the org-gtd package.
I like it so much I sponsor the creator.

******* Capture templates
These are the three kinds of notes I can make.

The "main" note is where I capture and write literature notes, or proper zettels.
These are not notes I take while reading.
Rather, they are the thoughts and questions I have that are inspired by the notes I take while reading, or even just in general.
They are what happens after I process information, not the processing itself.
They are also atomic, meaning each note only contains one idea.
For each new idea, make a new zettel.

Reference notes are for capturing information I want to cite or include in my literature notes.
They are mainly there to be bibliographic.
If necessary, I can write things like "on page 26 it says X."
I have a bookmarklet that will make reference notes from websites.
I have a separate function that makes reference notes from my Zotero library.

Articles are not from the original Zettelkasten method.
jethrokuan uses them as a place to write longer-form pieces, such as blog posts.
They are a good place to write notes that are more complicated.
#+begin_src elisp :tangle no :noweb-ref org-roam-capture-templates
org-roam-capture-templates
'(("m" "main" plain
   "%?"
   :if-new (file+head "main/${slug}.org"
                      "#+title: ${title}\n")
   :immediate-finish t
   :unnarrowed t)
  ("r" "reference" plain "%?"
   :if-new
   (file+head "reference/${slug}.org" "#+title: ${title}\n")
   :immediate-finish t
   :unnarrowed t)
  ("a" "article" plain "%?"
   :if-new
   (file+head "articles/${slug}.org" "#+title: ${title}\n#+filetags: :article:\n")
   :immediate-finish t
   :unnarrowed t))
#+end_src

******* Create the node property "type"
This returns the type based on which template I used.
#+begin_src elisp :tangle no :noweb-ref org-roam-node-type
(cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name (org-roam-node-file node) org-roam-directory))))
    (error "")))
#+end_src

******* Modify display template to show type
And this will show that type when I do a file search.
#+begin_src elisp :tangle no :noweb-ref org-roam-node-display-template
org-roam-node-display-template
(concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag))
#+end_src

******* Reference zettels
This is the autoloaded function that creates reference notes from my Zotero library.
#+begin_src elisp :tangle no :noweb-ref node-from-cite
(defun jc/org-roam-node-from-cite (keys-entries)
  (interactive (list (citar-select-ref :multiple nil    :rebuild-cache t)))
  (let ((title (citar--format-entry-no-widths (cdr keys-entries)
                                              "${author editor} :: ${title}")))
    (org-roam-capture- :templates
                       '(("r" "reference" plain "%?" :if-new
                          (file+head "reference/${citekey}.org"
                                     ":PROPERTIES:
:ROAM_REFS: [cite:@${citekey}]
:END:
,#+title: ${title}\n")
                          :immediate-finish t
                          :unnarrowed t))
                       :info (list :citekey (car keys-entries))
                       :node (org-roam-node-create :title title)
                       :props '(:finalize find-file))))
#+end_src

******* Every zettel is a draft
This autoloaded function adds the "draft" tag to each new node.
#+begin_src elisp :tangle no :noweb-ref new-node-as-draft
(defun jc/tag-new-node-as-draft ()
  (org-roam-tag-add '("draft")))
#+end_src

This hook makes that an automated process.
#+begin_src elisp :tangle no :noweb-ref node-draft-hook
(add-hook 'org-roam-capture-new-node-hook #'jc/tag-new-node-as-draft)
#+end_src

** Visual settings
*** Font face
Pretty standard.
I use the ever-popular Fira Code for any monospace typing, and I use Overpass for standard.
Sometimes I use Fira Sans or Alegreya instead of Overpass.
#+begin_src elisp :tangle no :noweb-ref fonts
(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
#+end_src

This is so I can use both monospace and regular fonts in the same buffer, mainly text modes.
You have to configure the ~mixed-pitch-set-height~ variable if you want to be able to use different font sizes for the two fonts.
#+begin_src elisp :tangle no :noweb-ref mixed-pitch
(use-package mixed-pitch
  :hook
  ;; If you want it in all text modes:
  (text-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-set-height t))
#+end_src

*** Theme
I change my theme a lot.
I don't like dark modes when the contrast is too high.
I don't like white modes when they're too bright.
Basically, I like muted, almost dusty tones with lower contrast.

Nord is usually my go-to.
I also have really enjoyed Opera and Opera Light lately.
Sometimes the color palette of Earl Grey isn't varied enough.
I like how Flatwhite highlights different elements.

I didn't think I liked Zenburn, but it turns out I do.
Let's give it a try.
#+begin_src elisp :tangle no :noweb-ref theme
;;(setq doom-theme 'doom-earl-grey)
;;(setq doom-theme 'doom-flatwhite)
;;(setq doom-theme 'doom-nord)
;;(setq doom-theme 'doom-opera)
;;(setq doom-theme 'doom-opera-light)
;;(setq doom-theme 'doom-wilmersdorf)
(setq doom-theme 'doom-zenburn)
#+end_src

*** Line numbers
You know, I normally don't like line numbers.
I like the clean, minimal look.
I've been turned on to relative line numbers recently because it makes it easy to move around the buffer.
You hit escape, the number of lines you want to move, and the direction.
#+begin_src elisp :tangle no :noweb-ref line-num
(setq display-line-numbers-type 'relative)
#+end_src

If this makes the performance slow, you can toggle them off manually with ~SPC t l~.

* Packages
** Consult-org-roam
This is a really fun package.
Basically, it gives a live preview feature to searching org-roam files, as well as some ripgrep functionality.
#+begin_src elisp :tangle no :noweb-ref p-consult-org-roam
(package! consult-org-roam
  :recipe (:host github :repo "jgru/consult-org-roam"))
#+end_src

The intended use is to use the functions below to do searching and have the live preview.
However, I noticed that after you trigger a function for the first time during a session, it gives the live preview feature to regular org-roam searching.
So, I did a hacky thing and figured out how to get that without using the package's functions.

I put the ~use-package!~ block within the org-roam block and demanded it, so it loads as soon as org-roam does.
#+begin_src elisp :tangle no :noweb-ref consult-org-roam
(use-package! consult-org-roam
  :demand t
  :bind
  (("C-c n e" . consult-org-roam-file-find)
   ("C-c n b" . consult-org-roam-backlinks)
   ("C-c n r" . consult-org-roam-search)))
#+end_src

** Doct
Doct is a nicer way of declaring org-capture templates.
#+begin_src elisp :tangle no :noweb-ref p-doct
(package! doct)
#+end_src

I don't really write my own templates, but I like the pretty setup tecosaur has, and I don't know how to get that without the doct setup he has.
So I figure, might as well use this, too.
#+begin_src elisp :tangle no :noweb-ref doct
(use-package! doct
  :commands doct)
#+end_src

All of the below blocks are from tecosaur, and I have them autoloaded.
#+begin_src elisp :tangle no :noweb-ref +doct-icon-declaration-to-icon
(defun +doct-icon-declaration-to-icon (declaration)
  "Convert :icon declaration to icon"
  (let ((name (pop declaration))
        (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
        (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
        (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
    (apply set `(,name :face ,face :v-adjust ,v-adjust))))
#+end_src

#+begin_src elisp :tangle no :noweb-ref +doct-iconify-capture-templates
(defun +doct-iconify-capture-templates (groups)
  "Add declaration's :icon to each template group in GROUPS."
  (let ((templates (doct-flatten-lists-in groups)))
    (setq doct-templates (mapcar (lambda (template)
                                   (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                               (spec (plist-get (plist-get props :doct) :icon)))
                                     (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                    "\t"
                                                                    (nth 1 template))))
                                   template)
                                 templates))))
#+end_src

** Hydra-posframe
This package is recommended by the major-mode-hydra package.
#+begin_src elisp :tangle no :noweb-ref p-hydra-posframe
(package! hydra-posframe
  :recipe (:host github :repo "Ladicle/hydra-posframe"))
#+end_src

This function puts the hydra posframe near the bottom of the frame.
I got the code from the maintainer or major-mode-hydra.
#+begin_src elisp :tangle no :noweb-ref jc-frame-bottom-poshandler
(defun jc-frame-bottom-poshandler (info)
  (let ((pos (posframe-poshandler-frame-center info)))
    (cons (car pos) (+ (cdr pos) 100))))
#+end_src

And this is where we configure the package.
#+begin_src elisp :tangle no :noweb-ref hydra-posframe
(use-package! hydra-posframe
  :hook (after-init . hydra-posframe-mode)
  :config
  (setq hydra-posframe-parameters '((alpha 100 100)
                                    (left-fringe . 10)
                                    (right-fringe . 10))
        hydra-posframe-poshandler 'jc-frame-bottom-poshandler))
#+end_src

** Info-colors
This just makes info pages look nicer.
It gives them colors, does some fontification, and enables mixed-pitch.
#+begin_src elisp :tangle no :noweb-ref p-info-colors
(package! info-colors)
#+end_src

I was having a hard time using the setup from tecosaur.
Maybe I need to go back and test again, now that I am using a theme that shows the colors better.
#+begin_src elisp :tangle no :noweb-ref info-colors
(use-package! info-colors
  :commands info-colors-fontify-node
  :init
  (add-hook 'Info-selection-hook #'info-colors-fontify-node))
#+end_src

** Major-mode-hydra
Major-mode-hydra provides the pretty-hydra package.
I had never really used hydras before, but the Zetteldesk package has suggested hydra keybindings and uses pretty-hydra.
#+begin_src elisp :tangle no :noweb-ref p-major-mode-hydra
(package! major-mode-hydra)
#+end_src

This function is from the maintainer of major-mode-hydra.
Basically, it shows the documentation for whatever item under the cursor in elisp mode.
#+begin_src elisp :tangle no :noweb-ref describe-foo-at-point
(defun describe-foo-at-point ()
  "Show the documentation of the Elisp function and variable near point.
This checks in turn:
-- for a function name where point is
-- for a variable name where point is
-- for a surrounding function call"
  (interactive)
  (let (sym)
    ;; sigh, function-at-point is too clever.  we want only the first half.
    (cond ((setq sym (ignore-errors
                       (with-syntax-table emacs-lisp-mode-syntax-table
                         (save-excursion
                           (or (not (zerop (skip-syntax-backward "_w")))
                               (eq (char-syntax (char-after (point))) ?w)
                               (eq (char-syntax (char-after (point))) ?_)
                               (forward-sexp -1))
                           (skip-chars-forward "`'")
                           (let ((obj (read (current-buffer))))
                             (and (symbolp obj) (fboundp obj) obj))))))
           (describe-function sym))
          ((setq sym (variable-at-point)) (describe-variable sym))
          ;; now let it operate fully -- i.e. also check the
          ;; surrounding sexp for a function call.
          ((setq sym (function-at-point)) (describe-function sym)))))
#+end_src

This generates the title of the hydra and an icon based on the major mode.
#+begin_src elisp :tangle no :noweb-ref jc-major-mode-hydra-title-generator
(defun jc-major-mode-hydra-title-generator (_)
  `(with-mode-icon major-mode
                   (propertize (s-concat (format-mode-line mode-name) " Commands")
                               'face '(:weight bold :height 1.1))
                   1.1))
#+end_src

And here is where we configure it.
I have a quit key that will cover all hydras made with this package.
And I also took the example elisp mode hydra.
#+begin_src elisp :tangle no :noweb-ref major-mode-hydra
(use-package major-mode-hydra
  :bind
  ("C-SPC" . major-mode-hydra)
  :config
  (setq major-mode-hydra-invisible-quit-key "q"
        major-mode-hydra-title-generator #'jc-major-mode-hydra-title-generator))

(major-mode-hydra-define emacs-lisp-mode nil
  ("Eval"
   (("b" eval-buffer "buffer")
    ("d" eval-defun "defun")
    ("e" eval-last-sexp "sexp")
    ("r" eval-region "region"))
   "REPL"
   (("I" ielm "ielm"))
   "Test"
   (("t" ert "prompt")
    ("T" (ert t) "all")
    ("F" (ert :failed) "failed"))
   "Doc"
   (("d" describe-foo-at-point "thing-at-pt")
    ("f" describe-function "function")
    ("v" describe-variable "variable")
    ("i" info-lookup-symbol "info lookup"))))
#+end_src

** Org-ol-tree
Org-ol-tree provides a side-buffer outline while in org mode.
I think it uses treemacs as its underlying package.
#+begin_src elisp :tangle no :noweb-ref p-org-ol-tree
(package! org-ol-tree
  :recipe (:host github :repo "Townk/org-ol-tree"))
#+end_src

A convenient keybinding.
#+begin_src elisp :tangle no :noweb-ref org-ol-tree
(use-package! org-ol-tree
  :commands org-ol-tree
  :init
  (map! :map org-mode-map
        :after org
        :localleader
        :desc "Outline" "O" #'org-ol-tree))
#+end_src

** Org-roam-desktop
Org-roam-desktop is meant to "emulate" the step of the Zettelkasten method where you take a cluster of notes and spread them on a desktop.
This gives you a visual overview of the notes in that topic cluster, and it makes it easy to arrange them, see new connections, etc.
#+begin_src elisp :tangle no :noweb-ref p-org-roam-desktop
(package! org-roam-desktop
  :recipe (:host github :repo "jgru/org-roam-desktop"))
#+end_src

This package creates a file for the desktop, and it can only add org-roam nodes.
When it adds a node to the desktop, it transcludes the content of the node.
#+begin_src elisp :tangle no :noweb-ref org-roam-desktop
(use-package! org-roam-desktop
  :after org
  :init
  (map! "C-c n d" #'org-roam-desktop
        "C-c n a" #'org-roam-desktop-node-add)
  :config
  (setq org-roam-desktop-basename   "*OR-Desk--"
        org-roam-desktop-directory  "~/Documents/org/digital-garden/org"))
#+end_src

** Org-transclusion
Org-transclusions gives you the ability to transclude text from one note into another.
It can make it easy to include quotations in a document without retyping them.
I also think you can use a certain function to edit the transcluded text and have it change in the original document.
And maybe the transcluded text changes when you edit the original document, but I'm not sure.
I'll need to test!
#+begin_src elisp :tangle no :noweb-ref p-org-transclusion
(package! org-transclusion)
#+end_src

This is the default configuration suggested by the package.
When I start using this package more, I'll change the keybindings.
#+begin_src elisp :tangle no :noweb-ref org-transclusion
(use-package! org-transclusion
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src

** Rotate
With this, you can rotate window layouts.
#+begin_src elisp :tangle no :noweb-ref p-rotate
(package! rotate)
#+end_src

** Zetteldesk
Zetteldesk, like org-roam-desktop, emulates spreading your cluster of notes on a desktop surface to arrange and whatnot.
It differs from org-roam-desktop in a few ways.
First, it creates a buffer instead of a document for the desktop, but you can always save that.
Two, it's not limited to org-roam nodes.
You can also add info pages, buffers, other org files, and PDFs into the desktop.
#+begin_src elisp :tangle no :noweb-ref p-zetteldesk
(package! zetteldesk
  :recipe (:host github :repo "Vidianos-Giannitsis/zetteldesk.el"))
#+end_src

This is the configuration I created as the suggested one for Doom users of the package.
Chiefly, this configuration uses the hydra keybindings.
I also made a mega configuration with other keybinding suggestions.
You can view it on the repo's [[https://github.com/Vidianos-Giannitsis/zetteldesk.el/wiki/Doom-Configuration][Wiki]].
#+begin_src elisp :tangle no :noweb-ref zetteldesk
(use-package! zetteldesk
  :after org-roam
  :config
  (setq zetteldesk-hydra-prefix (kbd "C-c z"))
  (zetteldesk-mode)
  (require 'zetteldesk-kb))
#+end_src

* Documents
** =config.el=
#+begin_src elisp :noweb yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!


;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets. It is optional.
<<personal-info>>

;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-unicode-font' -- for unicode glyphs
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
<<fonts>>
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;;(setq doom-theme 'doom-one)
<<theme>>

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
<<line-num>>

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
<<org-dirs>>


;; Whenever you reconfigure a package, make sure to wrap your config in an
;; `after!' block, otherwise Doom's defaults may override your settings. E.g.
;;
;;   (after! PACKAGE
;;     (setq x y))
;;
;; The exceptions to this rule:
;;
;;   - Setting file/directory variables (like `org-directory')
;;   - Setting variables which explicitly tell you to set them before their
;;     package is loaded (see 'C-h v VARIABLE' to look up their documentation).
;;   - Setting doom variables (which start with 'doom-' or '+').
;;
;; Here are some additional functions/macros that will help you configure Doom.
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;; Alternatively, use `C-h o' to look up a symbol (functions, variables, faces,
;; etc).
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.

<<simple-settings>>

<<frame-sizing>>

<<doom>>

<<citar>>

<<company>>

<<doct>>

<<modeline>>

<<evil>>

<<hydra-posframe>>

<<info-colors>>

<<major-mode-hydra>>

<<mixed-pitch>>

<<org>>

<<org-appear>>

<<org-ol-tree>>

<<org-roam-desktop>>

<<org-transclusion>>

<<zetteldesk>>
#+end_src

** =packages.el=
#+begin_src elisp :tangle packages.el :noweb yes
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)

<<p-consult-org-roam>>
<<p-doct>>
<<p-hydra-posframe>>
<<p-info-colors>>
<<p-major-mode-hydra>>
<<p-org-ol-tree>>
<<p-org-roam-desktop>>
<<p-org-transclusion>>
<<p-rotate>>
<<p-zetteldesk>>
#+end_src

** Autoloads
*** =hydras.el=
#+begin_src elisp :tangle autoload/hydras.el :noweb yes
;;; autoload/hydra-posframe.el -*- lexical-binding: t; -*-

;;;###autoload
<<describe-foo-at-point>>

;;;###autoload
<<jc-major-mode-hydra-title-generator>>
#+end_src

*** =icons.el=
#+begin_src elisp :tangle autoload/icons.el
;;; autoload/icons.el -*- lexical-binding: t; -*-

;;;###autoload
(defun with-faicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

;;;###autoload
(defun with-fileicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

;;;###autoload
(defun with-octicon (icon str &optional height v-adjust)
  (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

;;;###autoload
(defun with-material (icon str &optional height v-adjust)
  (s-concat (all-the-icons-material icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

;;;###autoload
(defun with-mode-icon (mode str &optional height nospace face)
  (let* ((v-adjust (if (eq major-mode 'emacs-lisp-mode) 0.0 0.05))
         (args     `(:height ,(or height 1) :v-adjust ,v-adjust))
         (_         (when face
                      (lax-plist-put args :face face)))
         (icon     (apply #'all-the-icons-icon-for-mode mode args))
         (icon     (if (symbolp icon)
                       (apply #'all-the-icons-octicon "file-text" args)
                     icon)))
    (s-concat icon (if nospace "" " ") str)))
#+end_src

*** =org-capture.el=
#+begin_src elisp :tangle autoload/org-capture.el :noweb yes
;;; autoload/org-capture.el -*- lexical-binding: t; -*-

;;;###autoload
<<org-capture-select-template-prettier>>

;;;###autoload
<<org-mks-pretty>>

;;;###autoload
<<+doct-icon-declaration-to-icon>>

;;;###autoload
<<+doct-iconify-capture-templates>>
#+end_src

*** =org-roam.el=
#+begin_src elisp :tangle autoload/org-roam.el :noweb yes
;;; autoload/org-roam.el -*- lexical-binding: t; -*-

;;;###autoload
<<node-from-cite>>

;;;###autoload
<<new-node-as-draft>>
#+end_src

*** =posframe.el=
#+begin_src elisp :tangle autoload/posframe.el :noweb yes
;;; autoload/posframe.el -*- lexical-binding: t; -*-

;;;###autoload
<<jc-frame-bottom-poshandler>>
#+end_src
